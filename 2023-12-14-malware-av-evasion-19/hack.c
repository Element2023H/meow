#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

typedef UINT(CALLBACK* fnMessageBoxA)(
  HWND   hWnd,
  LPCSTR lpText,
  LPCSTR lpCaption,
  UINT   uType
);

// macro to convert RVA to VA
#define RVA2VA(type, base, rva) ((type)((ULONG_PTR) base + rva))

// function to get the address of a function from the Export Address Table (EAT)
static LPVOID WINAPI getProcAddressfromEAT(LPVOID dllBase, const char *funcName) {
  PIMAGE_DOS_HEADER     dosh;
  PIMAGE_NT_HEADERS     nth;
  DWORD           numOfNames, va;
  PIMAGE_DATA_DIRECTORY   dataDir;
  PIMAGE_EXPORT_DIRECTORY exportDir;
  PDWORD          funcs;
  PDWORD          names;
  PWORD           ords;
  PCHAR           name;
  LPVOID          procAddr = NULL;
  
  dosh    = (PIMAGE_DOS_HEADER)dllBase;
  nth    = RVA2VA(PIMAGE_NT_HEADERS, dllBase, dosh->e_lfanew);
  dataDir  = (PIMAGE_DATA_DIRECTORY)nth->OptionalHeader.dataDir;
  va = dataDir[IMAGE_DIRECTORY_ENTRY_EXPORT].va;

  if (va == 0) return NULL;
  
  exportDir = RVA2VA(PIMAGE_EXPORT_DIRECTORY, dllBase, va);
  numOfNames   = exportDir->numOfNames;

  if (numOfNames == 0) return NULL;
  
  funcs = RVA2VA(PDWORD, dllBase, exportDir->AddressOfFunctions);
  names   = RVA2VA(PDWORD, dllBase, exportDir->AddressOfNames);
  ords  = RVA2VA(PWORD, dllBase, exportDir->AddressOfNameOrdinals);
  
  do {
    name = RVA2VA(PCHAR, dllBase, names[numOfNames - 1]);
    if (lstrcmpA(name, funcName) == 0) {
      procAddr = RVA2VA(LPVOID, dllBase, funcs[ords[numOfNames - 1]]);
      return procAddr;
    }
  } while (--numOfNames && procAddr == NULL);
  
  return procAddr;
}

int main() {
  // load your DLL
  HMODULE mod = LoadLibrary("user32.dll");
  LPVOID addr = getProcAddressfromEAT(mod, "MessageBox");
  if (addr != NULL) {
    fnMessageBoxA myMessageBoxA = (fnMessageBoxA)addr;
    printf("found at address 0x%p\n", addr);
  } else {
    printf("function not found.\n", funcName);
  }
  // free the module when done
  FreeLibrary(mod);
  return 0;
}
