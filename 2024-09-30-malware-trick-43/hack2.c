/*
 * hack2.c
 * shuffle bytes in payload
 * author: @cocomelonc
 * https://cocomelonc.github.io/malware/2024/09/30/malware-trick-43.html
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <windows.h>

// function to shuffle the bytes of a file
void shuffle_bytes(const char *input_file, const char *output_file, unsigned int seed) {
  // read the input file as bytes
  FILE *in = fopen(input_file, "rb");
  if (in == NULL) {
    perror("fopen input file failed");
    return;
  }

  // get the size of the file
  fseek(in, 0, SEEK_END);
  size_t size = ftell(in);
  fseek(in, 0, SEEK_SET);

  // allocate memory for the file data
  char *data = (char *)malloc(size);
  if (data == NULL) {
    perror("malloc failed");
    fclose(in);
    return;
  }

  // read the file data into the buffer
  if (fread(data, 1, size, in) != size) {
    perror("fread failed");
    fclose(in);
    free(data);
    return;
  }
  fclose(in);

  // create a list of indices
  int *indices = (int *)malloc(size * sizeof(int));
  if (indices == NULL) {
    perror("malloc failed");
    free(data);
    return;
  }
  for (size_t i = 0; i < size; ++i) {
    indices[i] = i;
  }

  // shuffle the indices
  srand(seed);
  for (size_t i = size - 1; i > 0; --i) {
    size_t j = rand() % (i + 1);
    int temp = indices[i];
    indices[i] = indices[j];
    indices[j] = temp;
  }

  // create a new buffer for shuffled data
  char *shuffled_data = (char *)malloc(size);
  if (shuffled_data == NULL) {
    perror("malloc failed");
    free(data);
    free(indices);
    return;
  }

  // rearrange the data according to shuffled indices
  for (size_t i = 0; i < size; ++i) {
    shuffled_data[i] = data[indices[i]];
  }

  // write the shuffled data to the output file
  FILE *out = fopen(output_file, "wb");
  if (out == NULL) {
    perror("fopen output file failed");
    free(data);
    free(indices);
    free(shuffled_data);
    return;
  }
  if (fwrite(shuffled_data, 1, size, out) != size) {
    perror("fwrite failed");
    fclose(out);
    free(data);
    free(indices);
    free(shuffled_data);
    return;
  }
  fclose(out);

  // free allocated memory
  free(data);
  free(indices);
  free(shuffled_data);
}

void deshuffle_bytes(char* data, size_t size, const char* output_file, unsigned int seed) {
  // create a list of indices
  int *indices = (int *)malloc(size * sizeof(int));
  if (indices == NULL) {
    perror("malloc failed");
    return;
  }
  for (size_t i = 0; i < size; ++i) {
    indices[i] = i;
  }

  // shuffle the indices
  srand(seed);
  for (size_t i = size - 1; i > 0; --i) {
    size_t j = rand() % (i + 1);
    int temp = indices[i];
    indices[i] = indices[j];
    indices[j] = temp;
  }

  // create a new buffer for deshuffled data
  char *deshuffled_data = (char *)malloc(size);
  if (deshuffled_data == NULL) {
    perror("malloc failed");
    free(indices);
    return;
  }

  // rearrange the data according to shuffled indices
  for (size_t i = 0; i < size; ++i) {
    deshuffled_data[indices[i]] = data[i]; 
  }

  // write the deshuffled data to the output file
  FILE *out = fopen(output_file, "wb");
  if (out == NULL) {
    perror("fopen output file failed");
    free(indices);
    free(deshuffled_data);
    return;
  }
  if (fwrite(deshuffled_data, 1, size, out) != size) {
    perror("fwrite failed");
    fclose(out);
    free(indices);
    free(deshuffled_data);
    return;
  }
  fclose(out);

  // Free allocated memory
  free(indices);
  free(deshuffled_data);
}

// function to shuffle a file and save it
void shuffle_file_and_save(const char *input_file, const char *output_file, unsigned int seed) {
  shuffle_bytes(input_file, output_file, seed);
}

int main() {
  const char *input_file = "meow.bin";
  const char *shuffled_file = "shuffled.bin";
  unsigned int seed = 12345;

  // shuffle the input file and save it
  shuffle_file_and_save(input_file, shuffled_file, seed);

  // read the shuffled file
  FILE *shuffled_fp = fopen(shuffled_file, "rb");
  if (shuffled_fp == NULL) {
    perror("fopen shuffled file failed");
    return 1;
  }
  fseek(shuffled_fp, 0, SEEK_END);
  size_t shuffled_size = ftell(shuffled_fp);
  fseek(shuffled_fp, 0, SEEK_SET);
  char *shuffled_data = (char *)malloc(shuffled_size);
  if (shuffled_data == NULL) {
    perror("malloc failed");
    fclose(shuffled_fp);
    return 1;
  }
  if (fread(shuffled_data, 1, shuffled_size, shuffled_fp) != shuffled_size) {
    perror("fread failed");
    fclose(shuffled_fp);
    free(shuffled_data);
    return 1;
  }
  fclose(shuffled_fp);

  // deshuffle the data
  const char *deshuffled_file = "deshuffled.bin";
  deshuffle_bytes(shuffled_data, shuffled_size, deshuffled_file, seed);

  free(shuffled_data);

  return 0;
}